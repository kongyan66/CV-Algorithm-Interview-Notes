# 学习进度

**[学进度汇总](https://gantt.mindsup.cn/project)**



# 第一章 变量和基本类型

**核心**：知道用什么数据类型去保存数据！

**变量**：具有类型、名称、可操作的存储空间。

**类型**：决定了变量所需要的内存空间、布局方式、以及能够表示值的范围。

### 1. 1 变量类型

不同变量的实际大小在不同机器上有所差异，精度决定了我们表达数据的范围。

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20221120220257146.png" alt="image-20221120220257146" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20221120214243782.png" alt="image-20221120214243782" style="zoom: 50%;" />

### 1.2 变量

变量是具有类型、名称、可操作的**存储空间**。



# 第四章 表达式

## 表达式基础

- **一元运算符与二元运算符**：作用于一个运算对象的运算符，如取址符(&)、解引用符(*)等是一元运算符；作用于两个运算对象是二元运算符，如相等运算符(==)

  和乘法运算符(*)。像`*`即是一元运算符有事二元运算符。

- **组合运算**：对于含有多个运算符复杂表达式，需要分析运算符的优先级、结合律、以及运算对象的求值顺序。

- **运算对象类型转换**：两个不同类型对象的运算就需要类型转换，如小整形类型会被提升为较大的整形类型。

- **左值与右值**：当一个对象被用作**右值**的时候，用的是对象的**值**（内容）；被用作左值时，用的是对象的身份(在内存中的位置)。并不是说等式右边就是右值。

  - 赋值运算一个左值作为其左侧运算对象，得到结果依然是一个左值。
  - 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针（右值）。

## 运算优先级与结合律

**运算优先级**

优先级与结合律规定了运算对象的组合方式，及决定哪些运算符先做运算。结合律就是从左到右的运算顺序。

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20221130204521178.png" alt="image-20221130204521178" style="zoom:80%;" />

**运算顺序**

优先级规定了运算对象的组合方式，但没有说明运算对象按照什么顺序求值。对于一些包含函数的复合运算就会产生未定义行为。

4种符号明确了求值顺序：逻辑与（`&&`）规定先求左侧值再右侧，只要左侧为真时才继续求右侧运算对象的值。另外三种分别是`||`、`？：`、`、`。

**特别注意**

- 括号无视优先级和结合律

## 算术运算符

- **溢出**：当计算的结果超出该类型所能表示的范围时就会产生溢出。
- **bool类型不应该参与计算**
  ```cpp
  bool b=true;
  bool b2=-b;   //仍然为true
  //b为true，提升为对应int=1，-b=-1
  //b2=-1≠0，所以b2仍未true
  ```
- 取余运算m%n，结果符号与m相同

## 逻辑运算符

- **短路求值**：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。**先左再右**
- 小技巧，声明为引用类型可以避免对元素的拷贝，如下，如string特别大时可以节省大量时间。
```cpp
vector<string> text;
for(const auto &s: text){
  cout<<s;
}
```

## 赋值运算符

- 赋值运算的**返回结果时它的左侧运算对象**，且是一个左值。类型也就是左侧对象的类型。
- 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。
- 赋值运算符满足**右结合律**，这点和其他二元运算符不一样。 `ival = jval = 0;`等价于`ival = (jval = 0);`
- 赋值运算优先级比较低，使用其当条件时应该加括号。
- 复合赋值运算符，**复合运算符只求值一次**，普通运算符求值两次。（对性能有一点点点点影响）
  任意复合运算符op等价于`a = a op b;`

## 递增递减运算符

* 前置版本`j = ++i`，先加一后赋值，j得到的是i+1后的值。
* 后置版本`j = i++`，先赋值后加一，j得到的是i+1前的值。

**优先使用前置**版本，后置多一步储存原始值。（除非需要变化前的值）

**混用解引用和递增运算符：**

`*iter++`等价于`*(iter++)`，递增优先级较高

```c++
auto iter = vi.begin();
while (iter!=vi.end()&&*iter>=0)
	cout<<*iter++<<endl;	// 输出当前值，指针向前移1
```

> **简介是一种美德**，追求简洁能降低程序出错可能性

## 成员访问运算符

`ptr->mem`等价于`(*ptr).mem`

注意`.`运算符优先级大于`*`，所以记得加括号

## 条件运算符

- 条件运算符（`?:`）允许我们把简单的`if-else`逻辑嵌入到单个表达式中去，按照如下形式：`cond? expr1: expr2`

- 可以嵌套使用，**右结合律**，从右向左顺序组合

  - ```c++
    finalgrade = (grade > 90) ? "high pass"
        : (grade < 60) ? "fail" : "pass";
    //等价于
    finalgrade = (grade > 90) ? "high pass"
        : （(grade < 60) ? "fail" : "pass"）;
    ```

- 输出表达式使用条件运算符记得加括号，条件运算符优先级太低。

## 位运算符

用于检查和设置二进制位的功能。

- 位运算符是作用于**整数类型**的运算对象。
- 二进制位向左移（`<<`）或者向右移（`>>`），移出边界外的位就被舍弃掉了。
- 位取反（`~`）（逐位求反）、与（`&`）、或（`|`）、异或（`^`）

有符号数负值可能移位后变号，所以强烈建议**位运算符仅用于无符号数**。

应用：

```c++
unsigned long quiz1 = 0;    // 每一位代表一个学生是否通过考试
1UL << 12;  // 代表第12个学生通过
quiz1 |= (1UL << 12);   // 将第12个学生置为已通过
quiz1 &= ~(1UL << 12);  // 将第12个学生修改为未通过
bool stu12 = quiz1 & (1UL << 12);   // 判断第12个学生是否通过
```

> 位运算符使用较少，但是重载cout、cin大家都用过

位运算符满足左结合律，优先级介于中间，使用时尽量加括号。

## sizeof运算符

- 返回一条表达式或一个类型名字所占的**字节数**。
- 返回的类型是 `size_t`的常量表达式。
- `sizeof`并不实际计算其运算对象的值。
- 两种形式：
  1. `sizeof (type)`，给出类型名
  2. `sizeof expr`，给出表达式
- 对数组执行sizeof运算得到整个数组所占空间大小。

```c++
int ia[10];
// sizeof(ia)返回整个数组所占空间的大小
// sizeof(ia)/sizeof(*ia)返回数组的大小
constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr[sz];
```

- 对string对象和vector对象执行sizeof 只返回该类型固定部分的大小，不会计算对象中元素占了多少空间。

## 逗号运算符

从左向右依次求值。

左侧求值结果丢弃，逗号运算符**结果是右侧表达式**的值。

## 类型转换

**隐式类型转换：**

> 设计为尽可能避免损失精度，即转换为更精细类型。

- 比 `int`类型小的整数值先提升为较大的整数类型。
- 条件中，非布尔转换成布尔。
- 初始化中，初始值转换成变量的类型。
- 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。
- 函数调用时也会有转换。

**算术转换：**

运算过程中产生的类型变换，如后也一个操作量会转换为前一个操作量的数据类型。

**整型提升**

* 常见的char、bool、short能存在int就会转换成int，否则提升为`unsigned int`
* `wchar_t,char16_t,char32_t`提升为整型中`int,long,long long ……`最小的，且能容纳原类型所有可能值的类

**显式类型转换（尽量避免）**

- **static_cast**：任何明确定义的类型转换，只要不包含底层const，都可以使用。 `double slope = static_cast<double>(j);`

- **dynamic_cast**：支持运行时类型识别。

- **const_cast**：只能改变运算对象的底层const，一般可用于去除const性质。 `const char *pc; char *p = const_cast<char*>(pc)`

  > 只有其可以改变常量属性

- **reinterpret_cast**：通常为运算对象的位模式提供低层次上的重新解释。



# 第五章 语句

## 简单语句

- **表达式语句**：一个表达式末尾加上分号，就变成了表达式语句。
- **空语句**：只有一个单独的分号。
- **复合语句（块）**：用花括号 `{}`包裹起来的语句和声明的序列。**一个块就是一个作用域**。

## 条件语句

- **悬垂else**（dangling else）：用来描述在嵌套的`if else`语句中，如果`if`比`else`多时如何处理的问题。C++使用的方法是`else`匹配最近没有配对的`if`。
- switch语句中不允许跨过变量初始化语句直接跳转到该变量作用域内的另一个位置（P163），如果必须可以用`{}`将变量定义在块内，确保后面的所有case标签都在变量作用域之外。

## 迭代语句

- **while**：当不确定到底要迭代多少次时，使用 `while`循环比较合适，比如读取输入的内容。
- **for**： `for`语句可以省略掉 `init-statement`， `condition`和 `expression`的任何一个；**甚至全部**。
- **范围for**： `for (declaration: expression) statement`，常用于数组、string、vector等序列对象的迭代操作。
- **do while**：先执行，再判断（至少循环一次）。变量要定义在循环体外部。

## 跳转语句

- **break**：`break`语句负责终止离它最近的`while`、`do while`、`for`或者`switch`语句，并从这些语句之后的第一条语句开始继续执行。
- **continue**：终止最近的循环中的当前迭代并立即开始下一次迭代。只能在`while`、`do while`、`for`循环的内部。
- **go to**: 无条件跳转到同一个函数内的另一条语句（**不推荐使用**）。

## try语句块和异常处理

- **throw表达式**：异常检测部分使用 `throw`表达式来表示它遇到了无法处理的问题。我们说 `throw`引发 `raise`了异常。`runtime_error`是标准库异常类型的一种，定义在`stdexcept`头文件中。
- **try语句块**：以 `try`关键词开始，以一个或多个 `catch`字句结束。 `try`语句块中的代码抛出的异常通常会被某个 `catch`捕获并处理。 `catch`子句也被称为**异常处理代码**。
- **异常类**：用于在 `throw`表达式和相关的 `catch`子句之间传递异常的具体信息。分别定义在4个头文件中：
  - `exception`头文件：最通用的异常类，只报告异常的发生，不提供额外信息
  - `stdexcept`头文件：定义几个常用的异常类
  - `new`头文件：bad_alloc异常类
  - `type_info`头文件：bad_cast异常类



# 第六章 函数

## 函数基础

- **函数定义**：包括返回类型、函数名字和0个或者多个**形参**（parameter）组成的列表和函数体。
- **调用运算符**：调用运算符的形式是一对圆括号 `()`，作用于一个表达式，该表达式是函数或者指向函数的指针。
- 圆括号内是用逗号隔开的**实参**（argument）列表。
- 函数调用过程：
  - 1.主调函数（calling function）的执行被中断。
  - 2.被调函数（called function）开始执行。
- **形参和实参**：形参和实参的**个数**和**类型**必须匹配上。
- **返回类型**： `void`表示函数不返回任何值。函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。
- **名字**：名字的作用于是程序文本的一部分，名字在其中可见。

### 局部对象

- **生命周期**：对象的生命周期是程序执行过程中该对象存在的一段时间。
- **局部变量**（local variable）：形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的，对函数外部而言是**隐藏**的。
- **自动对象**：只存在于块执行期间的对象。当块的执行结束后，它的值就变成**未定义**的了。
- **局部静态对象**： `static`类型的局部变量，生命周期贯穿函数调用前后。

### 函数声明

- **函数声明**：函数的声明和定义唯一的区别是声明无需函数体，用一个分号替代。函数声明主要用于描述函数的接口，也称**函数原型**。
- **在头文件中进行函数声明**：建议变量在头文件中声明；在源文件中定义。
- **分离编译**： `CC a.cc b.cc`直接编译生成可执行文件；`CC -c a.cc b.cc`编译生成对象代码`a.o b.o`； `CC a.o b.o`编译生成可执行文件。

## 参数传递

- 形参初始化的机理和变量初始化一样。
- **引用传递**（passed by reference）：又称传引用调用（called by reference），指**形参是引用类型**，引用形参是它对应的实参的别名。
  - 可以直接操作引用参数所引的对象
  - 避免拷贝大的数据类型对象或者容器类型对象
  - 使用引用形参可以帮助我们从函数中返回多个值
- **值传递**（passed by value）：又称传值调用（called by value），指实参的值是通过**拷贝**传递给形参。
  - `void f(T)`的参数通过值传递，在函数中`T`是实参的副本，改变`T`不会影响到原来的实参。

### 传值参数

- 当初始化一个非引用类型的变量时，初始值被拷贝给变量。
- 函数对形参做的所有操作都不会影响实参。
- 指针形参：常用在C中，`C++`建议使用引用类型的形参代替指针。

### 传引用参数

- 通过使用引用形参，允许函数改变一个或多个实参的值。
- 引用形参直接关联到绑定的对象，而非对象的副本。
- 使用引用形参可以用于**返回额外的信息**。
- 经常用引用形参来避免不必要的复制。
- `void swap(int &v1, int &v2)`
- 如果无需改变引用形参的值，最好将其声明为常量引用。

### const形参和实参

- 形参的顶层`const`被忽略。`void func(const int i);`调用时既可以传入`const int`也可以传入`int`。
- 我们可以使用非常量初始化一个底层`const`对象，但是反过来不行。
- 在函数中，不能改变实参的**局部副本**。
- 尽量使用常量引用。

### 数组形参

- 我们把数组作为为函数形参时，有三种可以选择的形式：

  - 声明为指针 
  - 声明为不限维度的数组
  - 维度确定的数组

- 当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。
- 要注意数组的实际长度，不能越界。

### main处理命令行选项

- `int main(int argc, char *argv[]){...}`
- 第一个形参代表参数的个数；第二个形参是参数C风格字符串数组。

### 可变形参

`initializer_list`提供的操作（`C++11`）：

| 操作                                 | 解释                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| `initializer_list<T> lst;`           | 默认初始化；`T`类型元素的空列表                              |
| `initializer_list<T> lst{a,b,c...};` | `lst`的元素数量和初始值一样多；`lst`的元素是对应初始值的副本；列表中的元素是`const`。 |
| `lst2(lst)`                          | 拷贝或赋值一个`initializer_list`对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 |
| `lst2 = lst`                         | 同上                                                         |
| `lst.size()`                         | 列表中的元素数量                                             |
| `lst.begin()`                        | 返回指向`lst`中首元素的指针                                  |
| `lst.end()`                          | 返回指向`lst`中微元素下一位置的指针                          |

`initializer_list`使用demo：

```cpp
void err_msg(ErrCode e, initializer_list<string> il){
    cout << e.msg << endl;
    for (auto bed = il.begin(); beg != il.end(); ++ beg)
        cout << *beg << " ";
    cout << endl;
}

err_msg(ErrCode(0), {"functionX", "okay});
```

- 所有实参类型相同，可以使用 `initializer_list`的标准库类型。
- 实参类型不同，可以使用`可变参数模板`。
- 省略形参符： `...`，便于`C++`访问某些C代码，这些C代码使用了 `varargs`的C标准功能。

## 返回类型和return语句

### 无返回值函数

没有返回值的 `return`语句只能用在返回类型是 `void`的函数中，返回 `void`的函数不要求非得有 `return`语句。

### 有返回值函数

- `return`语句的返回值的类型必须和函数的返回类型相同，或者能够**隐式地**转换成函数的返回类型。
- 值的返回：返回的值用于初始化调用点的一个**临时量**，该临时量就是函数调用的结果。
- **不要返回局部对象的引用或指针**。
- **引用返回左值**：函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值；其他返回类型得到右值。
- **列表初始化返回值**：函数可以返回花括号包围的值的列表。（`C++11`）
- **主函数main的返回值**：如果结尾没有`return`，编译器将隐式地插入一条返回0的`return`语句。返回0代表执行成功。main函数不能调用自己。

### 返回数组指针

- `Type (*function (parameter_list))[dimension]`
- 使用类型别名： `typedef int arrT[10];` 或者 `using arrT = int[10;]`，然后 `arrT* func() {...}`
- 使用 `decltype`： `decltype(odd) *arrPtr(int i) {...}`
- **尾置返回类型**： 在形参列表后面以一个`->`开始：`auto func(int i) -> int(*)[10]`（`C++11`）

## 函数重载

- **重载**：如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。
- `main`函数不能重载。
- **重载和const形参**：
  - 一个有顶层const的形参和没有它的函数无法区分。 `Record lookup(Phone* const)`和 `Record lookup(Phone*)`无法区分。
  - 相反，是否有某个底层const形参可以区分。 `Record lookup(Account*)`和 `Record lookup(const Account*)`可以区分。
- **重载和作用域**：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名。

## 特殊用途语言特性

### 默认实参

- `string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');`
- 一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值。

### 内联（inline）函数

C++ **内联函数**是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

- 普通函数的缺点：调用函数比求解等价表达式要慢得多。
- `inline`函数可以避免函数调用的开销，可以让编译器在编译时**内联地展开**该函数。
- `inline`函数应该在头文件中定义。

### constexpr函数

- 指能用于常量表达式的函数。
- `constexpr int new_sz() {return 42;}`
- 函数的返回类型及所有形参类型都要是字面值类型。
- `constexpr`函数应该在头文件中定义。

### 调试帮助

`assert`预处理宏（preprocessor macro）：`assert(expr);`

开关调试状态：

`CC -D NDEBUG main.c`可以定义这个变量`NDEBUG`。

```cpp
void print(){
    #ifndef NDEBUG
        cerr << __func__ << "..." << endl;
    #endif
}
```

## 函数匹配

重载函数匹配的**三个步骤**：1.候选函数；2.可行函数；3.寻找最佳匹配。

- **候选函数**：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。
- **可行函数**：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。
- **寻找最佳匹配**：基本思想：实参类型和形参类型越接近，它们匹配地越好。如果有二义性则编译器报错。

编译器将实参类型到形参类型的转换划分几个等级：

1. 精准匹配
2. 通过const准换实现匹配
3. 通过类型提升实现的匹配
4. 通过算术类型转换实现的匹配
5. 通过类类型转换实现的匹配

## 函数指针

指向函数的指针。

- `bool (*pf)(const string &, const string &);` 注：两端的括号不可少。
- **函数指针形参**：
  - 形参中使用函数定义或者函数指针定义效果一样。
  - 使用类型别名或者`decltype`。
- **返回指向函数的指针**：1.类型别名；2.尾置返回类型。

# 第七章 类 （Class）

## 定义抽象数据类型

- **类背后的基本思想**：**数据抽象**（data abstraction）和**封装**（encapsulation）。
- 数据抽象是一种依赖于**接口**（interface）和**实现**（implementation）分离的编程技术。

### 类成员 （Member）

- 必须在类的内部声明，不能在其他地方增加成员。
- 成员可以是数据，函数，类型别名。

### 类的成员函数

- 成员函数的**声明**必须在类的内部。
- 成员函数的**定义**既可以在类的内部也可以在外部。
- 使用点运算符 `.` 调用成员函数。
- 必须对任何`const`或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。
- `ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { }`
- 默认实参： `Sales_item(const std::string &book): isbn(book), units_sold(0), revenue(0.0) { }`
- `*this`：
  - 每个成员函数都有一个额外的，隐含的形参`this`。
  - `this`总是指向当前对象，因此`this`是一个常量指针。
  - 形参表后面的`const`，改变了隐含的`this`形参的类型，如 `bool same_isbn(const Sales_item &rhs) const`，这种函数称为“常量成员函数”（`this`指向的当前对象是常量）。
  - `return *this;`可以让成员函数连续调用。
  - 普通的非`const`成员函数：`this`是指向类类型的`const`指针（可以改变`this`所指向的值，不能改变`this`保存的地址）。
  - `const`成员函数：`this`是指向const类类型的`const`指针（既不能改变`this`所指向的值，也不能改变`this`保存的地址）。

```
Sales_data::avg_price() ::为作用域运算符 说明如下事实：我们定义了一个名为avg_price的函数，并且该函数被声明在类sales_data的作用域内。一旦编译器看到这个函数名，就知道剩余代码是位于类的作用域内的，也就能正常常用类的成员了。
```

### 非成员函数

- 和类相关的非成员函数，定义和声明都应该在类的外部。

### 类的构造函数

- 类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。
- 构造函数是特殊的成员函数。
- 构造函数放在类的`public`部分。
- 与类同名的成员函数。
- `Sales_item(): units_sold(0), revenue(0.0) { }`
- `=default`要求编译器合成默认的构造函数。(`C++11`)
- 初始化列表：冒号和花括号之间的代码： `Sales_item(): units_sold(0), revenue(0.0) { }`

## 访问控制与封装

- **访问说明符**（access specifiers）：
  - `public`：定义在 `public`后面的成员在整个程序内可以被访问； `public`成员定义类的接口。
  - `private`：定义在 `private`后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； `private`隐藏了类的实现细节。
- 使用 `class`或者 `struct`：都可以被用于定义一个类。唯一的却别在于访问权限。
  - 使用 `class`：在第一个访问说明符之前的成员是 `private`的（默认是private的)。
  - 使用 `struct`：在第一个访问说明符之前的成员是 `public`的 (默认是public的)。

### 友元

允许特定的**非成员函数**访问一个类的**私有成员**.

- 友元的声明以关键字 `friend`开始。 `friend Sales_data add(const Sales_data&, const Sales_data&);`表示非成员函数`add`可以访问类的非公有成员。
- 友元的声明只能出现在类定义的内部，但在类内出现的具体位置不限制，但最好在类定义开始的位置集中声明友元。
- 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。
- 如果用户想调用这个友元函数，需要在类外对友元函数进行再一次声明。

### 封装的益处

- 确保用户的代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

## 类的其他特性

- **类型成员**

  自定义一个关键字来代替某一类型。

- **内联函数 `inline`**：

  - 类中定义的函数都是内联函数，即使没有使用incline说明符，有也是可以的。

  - 在类外部定义的成员函数，也可以在声明时显式地加上 `inline`。

- **可变数据成员** （mutable data member）：
  
  - `mutable size_t access_ctr;`
  - 永远不会是`const`，即使它是`const`对象的成员。
  
- **返回`*this`成员函数**

  这样才能连续调用，这样才能对同一个对象进行连续操作，形如：

  ```
  myscreen.move(4, 0).set('#')
  ```

- **类类型**：

  每个类定义了唯一的数据类型。对于两个类来说，即使他们他们的成员完全一样，这两个类也是不同的类型。

## 类的作用域

- 每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。
- 函数的**返回类型**通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。
- 如果成员使用了外层作用域中的某个名字，而该名字代表一种**类型**，则类不能在之后重新定义该名字。
- 类中的**类型名定义**都要放在一开始。

## 构造函数再探

- 构造函数初始值列表：
  - 类似`python`使用赋值的方式有时候不行，比如`const`或者引用类型的数据，只能初始化，不能赋值。（注意初始化和赋值的区别）
  - 最好让构造函数初始值的顺序和成员声明的顺序保持一致。
  - 如果一个构造函数为所有参数都提供了默认参数，那么它实际上也定义了默认的构造函数。

### 委托构造函数 （delegating constructor, `C++11`）

- 委托构造函数将自己的职责委托给了其他构造函数。
- `Sale_data(): Sale_data("", 0, 0) {}`

### 隐式的类型转换

- 如果构造函数**只接受一个实参**，则它实际上定义了转换为此类类型的**隐式转换机制**。这种构造函数又叫**转换构造函数**（converting constructor）。
- 编译器只会自动地执行`仅一步`类型转换。
- 抑制构造函数定义的隐式转换：
  - 将构造函数声明为`explicit`加以阻止。
  - `explicit`构造函数只能用于直接初始化，不能用于拷贝形式的初始化。

### 聚合类 （aggregate class）

- 满足以下所有条件：
  - 所有成员都是`public`的。
  - 没有定义任何构造函数。
  - 没有类内初始值。
  - 没有基类，也没有`virtual`函数。
- 可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致。

### 字面值常量类

- `constexpr`函数的参数和返回值必须是字面值。
- **字面值类型**：除了算术类型、引用和指针外，某些类也是字面值类型。
- 数据成员都是字面值类型的聚合类是字面值常量类。
- 如果不是聚合类，则必须满足下面所有条件：
  - 数据成员都必须是字面值类型。
  - 类必须至少含有一个`constexpr`构造函数。
  - 如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的`constexpr`构造函数。
  - 类必须使用析构函数的默认定义，该成员负责销毁类的对象。

## 类的静态成员

为了让相同类不同对象之间共享同一个变量或者函数，于是有了静态成员。

非`static`数据成员存在于类类型的每个对象中，而`static`数据成员独立于该类的任意对象而存在。每个`static`数据成员是与类关联的对象，并不与该类的对象相关联。

- 声明：
  - 声明之前加上关键词`static`。
- 使用：
  - 使用**作用域运算符**`::`直接访问静态成员:`r = Account::rate();`
  - 也可以使用对象访问：`r = ac.rate();`
- 定义：
  - 在类外部定义时不用加`static`。
- 初始化：
  - 通常不在类的内部初始化，而是在定义时进行初始化，如 `double Account::interestRate = initRate();`
  - 如果一定要在类内部定义，则要求必须是字面值常量类型的`constexpr`。
  

# 第八章 IO库

**前面章节已经在用的IO库设施**

- **istream**：输入流类型，提供输入操作。
- **ostream**：输出流类型，提供输出操作
- **cin**：一个`istream`对象，从标准输入读取数据。
- **cout**：一个`ostream`对象，向标准输出写入数据。
- **cerr**：一个`ostream`对象，向标准错误写入消息。
- **>>运算符**：用来从一个`istream`对象中读取输入数据。
- **<<运算符**：用来向一个`ostream`对象中写入输出数据。
- **getline函数**：从一个给定的`istream`对象中读取一行数据，存入到一个给定的`string`对象中。
  
## IO类

### 标准库定义的IO类型

- `iostream`头文件：从标准流中读写数据，`istream`、`ostream`等。
- `fstream`头文件：从文件中读写数据，`ifstream`、`ofstream`等。
- `sstream`头文件：从字符串中读写数据，`istringstream`、`ostringstream`

### IO对象不可复制或赋值

- 1.IO对象不能存在容器里.
- 2.形参和返回类型也不能是流类型。
- 3.形参和返回类型一般是流的**引用**。
- 4.读写一个IO对象会改变其状态，因此传递和返回的引用不能是`const`的。

### 条件状态

| 状态                | 解释                                                         |
| ------------------- | ------------------------------------------------------------ |
| `strm:iostate`      | 是一种机器无关的**类型**，提供了表达条件状态的完整功能       |
| `strm:badbit`       | 用来指出流已经崩溃                                           |
| `strm:failbit`      | 用来指出一个IO操作失败了                                     |
| `strm:eofbit`       | 用来指出流到达了文件结束                                     |
| `strm:goodbit`      | 用来指出流未处于错误状态，此值保证为零                       |
| `s.eof()`           | 若流`s`的`eofbit`置位，则返回`true`                          |
| `s.fail()`          | 若流`s`的`failbit`置位，则返回`true`                         |
| `s.bad()`           | 若流`s`的`badbit`置位，则返回`true`                          |
| `s.good()`          | 若流`s`处于有效状态，则返回`true`                            |
| `s.clear()`         | 将流`s`中所有条件状态位复位，将流的状态设置成有效，返回`void` |
| `s.clear(flags)`    | 将流`s`中指定的条件状态位复位，返回`void`                    |
| `s.setstate(flags)` | 根据给定的标志位，将流`s`中对应的条件状态位置位，返回`void`  |
| `s.rdstate()`       | 返回流`s`的当前条件状态，返回值类型为`strm::iostate`         |

上表中，`strm`是一种IO类型，（如`istream`）， `s`是一个流对象。

### 管理输出缓冲

- 每个输出流都管理一个缓冲区，执行输出的代码，文本串可能立即打印出来，也可能被操作系统保存在缓冲区内，随后再打印。
- 刷新缓冲区，可以使用如下IO操纵符：
  - `endl`：输出一个换行符并刷新缓冲区。
  - `flush`：刷新流，单不添加任何字符。
  - `ends`：在缓冲区插入空字符`null`，然后刷新。
  - `unitbuf`：告诉流接下来每次操作之后都要进行一次`flush`操作。
  - `nounitbuf`：回到正常的缓冲方式。

## 文件输入输出

- 头文件`fstream`定义了三个类型来支持文件IO：
  - `ifstream`从一个给定文件读取数据。
  - `ofstream`向一个给定文件写入数据。
  - `fstream`可以读写给定文件。
- **文件流**：需要读写文件时，必须定义自己的文件流对象，并绑定在需要的文件上。

### fstream特有的操作

| 操作                      | 解释                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `fstream fstrm;`          | 创建一个未绑定的文件流。                                     |
| `fstream fstrm(s);`       | 创建一个文件流，并打开名为`s`的文件，`s`可以是`string`也可以是`char`指针 |
| `fstream fstrm(s, mode);` | 与前一个构造函数类似，但按指定`mode`打开文件                 |
| `fstrm.open(s)`           | 打开名为`s`的文件，并和`fstrm`绑定                           |
| `fstrm.close()`           | 关闭和`fstrm`绑定的文件                                      |
| `fstrm.is_open()`         | 返回一个`bool`值，指出与`fstrm`关联的文件是否成功打开且尚未关闭 |

上表中，`fstream`是头文件`fstream`中定义的一个类型，`fstrm`是一个文件流对象。

### 文件模式

| 文件模式 | 解释                         |
| -------- | ---------------------------- |
| `in`     | 以读的方式打开               |
| `out`    | 以写的方式打开               |
| `app`    | 每次写操作前均定位到文件末尾 |
| `ate`    | 打开文件后立即定位到文件末尾 |
| `trunc`  | 截断文件                     |
| `binary` | 以二进制方式进行IO操作。     |

## string流

- 头文件`sstream`定义了三个类型来支持内存IO：
  - `istringstream`从`string`读取数据。
  - `ostringstream`向`string`写入数据。
  - `stringstream`可以读写给定`string`。

### stringstream特有的操作

| 操作              | 解释                               |
| ----------------- | ---------------------------------- |
| `sstream strm`    | 定义一个未绑定的`stringstream`对象 |
| `sstream strm(s)` | 用`s`初始化对象                    |
| `strm.str()`      | 返回`strm`所保存的`string`的拷贝   |
| `strm.str(s)`     | 将`s`拷贝到`strm`中，返回`void`    |

上表中`sstream`是头文件`sstream`中任意一个类型。`s`是一个`string`。

# 第九章 顺序容器

## 顺序容器概述

**顺序容器**（sequential container）：为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。

### 顺序容器类型

| 容器类型       | 介绍                                                         |
| -------------- | ------------------------------------------------------------ |
| `vector`       | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。 |
| `deque`        | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。    |
| `list`         | 双向链表。只支持双向顺序访问。在`list`中任何位置进行插入/删除操作速度都很快。不支持随机访问。 |
| `forward_list` | 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。 |
| `array`        | 固定大小数组。支持快速随机访问。不能添加或者删除元素。       |
| `string`       | 与`vector`相似的容器，但专门用于保存字符。随机访问块。在尾部插入/删除速度快。 |

- 除了固定大小的`array`外，其他容器都提供高效、灵活的内存管理。
- `forward_list`和`array`是新C++标准增加的类型。
- 通常使用`vector`是最好的选择，除非你有很好的理由选择其他容器。
- 新标准库的容器比旧版的快得多。

## 容器操作

### 类型

| 操作              | 解释                                               |
| ----------------- | -------------------------------------------------- |
| `iterator`        | 此容器类型的迭代器类型                             |
| `const_iterator`  | 可以读取元素但不能修改元素的迭代器类型             |
| `size_type`       | 无符号整数类型，足够保存此种容器类型最大可能的大小 |
| `difference_type` | 带符号整数类型，足够保存两个迭代器之间的距离       |
| `value_type`      | 元素类型                                           |
| `reference`       | 元素的左值类型；和`value_type &`含义相同           |
| `const_reference` | 元素的`const`左值类型，即`const value_type &`      |

### 构造函数

即对容器进行初始化

| 操作                      | 解释                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `C c;`                    | 默认构造函数，构造空容器                                     |
| `C c1(c2);`或`C c1 = c2;` | 构造`c2`的拷贝`c1`                                           |
| `C c(b, e)`               | 构造`c`，将迭代器`b`和`e`指定范围内的所有元素拷贝到`c`       |
| `C c(a, b, c...)`         | 列表初始化`c`                                                |
| `C c(n)`                  | 只支持顺序容器，且不包括`array`，包含`n`个元素，这些元素进行了值初始化 |
| `C c(n, t)`               | 包含`n`个初始值为`t`的元素                                   |

- 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。
- `array`具有固定大小。
- 和其他容器不同，默认构造的`array`是非空的。
- 直接复制：将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。
- 使用迭代器复制：不要求容器类型相同，容器内的元素类型也可以不同。

### 赋值和`swap`

| 操作                | 解释                                                         |
| ------------------- | ------------------------------------------------------------ |
| `c1 = c2;`          | 将`c1`中的元素替换成`c2`中的元素                             |
| `c1 = {a, b, c...}` | 将`c1`中的元素替换成列表中的元素（不适用于`array`）          |
| `c1.swap(c2)`       | 交换`c1`和`c2`的元素                                         |
| `swap(c1, c2)`      | 等价于`c1.swap(c2)`                                          |
| `c.assign(b, e)`    | 将`c`中的元素替换成迭代器`b`和`e`表示范围中的元素，`b`和`e`不能指向`c`中的元素 |
| `c.assign(il)`      | 将`c`中的元素替换成初始化列表`il`中的元素                    |
| `c.assign(n, r)`    | 将`c`中的元素替换为`n`个值是`t`的元素                        |

- 使用非成员版本的`swap`是一个好习惯。
- `assign`操作不适用于关联容器和`array`

### 大小

| 操作           | 解释                                           |
| -------------- | ---------------------------------------------- |
| `c.size()`     | `c`中元素的数目（不支持`forward_list`）        |
| `c.max_size()` | `c`中可保存的最大元素数目                      |
| `c.empty()`    | 若`c`中存储了元素，返回`false`，否则返回`true` |

### 添加元素

| 操作                    | 解释                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `c.push_back(t)`        | 在`c`尾部创建一个值为`t`的元素，返回`void`                   |
| `c.emplace_back(args)`  | 同上                                                         |
| `c.push_front(t)`       | 在`c`头部创建一个值为`t`的元素，返回`void`                   |
| `c.emplace_front(args)` | 同上                                                         |
| `c.insert(p, t)`        | 在迭代器`p`指向的元素之前创建一个值是`t`的元素，返回指向新元素的迭代器 |
| `c.emplace(p, args)`    | 同上                                                         |
| `c.insert(p, n, t)`     | 在迭代器`p`指向的元素之前插入`n`个值为`t`的元素，返回指向第一个新元素的迭代器；如果`n`是0，则返回`p` |
| `c.insert(p, b, e)`     | 将迭代器`b`和`e`范围内的元素，插入到`p`指向的元素之前；如果范围为空，则返回`p` |
| `c.insert(p, il)`       | `il`是一个花括号包围中的元素值列表，将其插入到`p`指向的元素之前；如果`il`是空，则返回`p` |

- 因为这些操作会改变大小，因此不适用于`array`。
- `forward_list`有自己专有版本的`insert`和`emplace`。
- `forward_list`不支持`push_back`和`emplace_back`。
- 当我们用一个对象去初始化容器或者将对象插入到容器时，实际上放入的是对象的拷贝。
- `emplace`开头的函数是新标准引入的，这些操作是构造而不是拷贝元素。
- 传递给`emplace`的参数必须和元素类型的构造函数相匹配。

### 访问元素

| 操作        | 解释                                                         |
| ----------- | ------------------------------------------------------------ |
| `c.back()`  | 返回`c`中尾元素的引用。若`c`为空，函数行为未定义             |
| `c.front()` | 返回`c`中头元素的引用。若`c`为空，函数行为未定义             |
| `c[n]`      | 返回`c`中下标是`n`的元素的引用，`n`时候一个无符号证书。若`n>=c.size()`，则函数行为未定义 |
| `c.at(n)`   | 返回下标为`n`的元素引用。如果下标越界，则抛出`out_of_range`异常 |

- 访问成员函数返回的是引用。
- `at`和下标操作只适用于`string`、`vector`、`deque`、`array`。
- `back`不适用于`forward_list`。
- 如果希望下标是合法的，可以使用`at`函数。

### 删除元素

| 操作            | 解释                                                         |
| --------------- | ------------------------------------------------------------ |
| `c.pop_back()`  | 删除`c`中尾元素，若`c`为空，则函数行为未定义。函数返回`void` |
| `c.pop_front()` | 删除`c`中首元素，若`c`为空，则函数行为未定义。函数返回`void` |
| `c.erase(p)`    | 删除迭代器`p`指向的元素，返回一个指向被删除元素之后的元素的迭代器，若`p`本身是尾后迭代器，则函数行为未定义 |
| `c.erase(b, e)` | 删除迭代器`b`和`e`范围内的元素，返回指向最后一个被删元素之后元素的迭代器，若`e`本身就是尾后迭代器，则返回尾后迭代器 |
| `c.clear()`     | 删除`c`中所有元素，返回`void`                                |

- 会改变容器大小，不适用于`array`。
- `forward_list`有特殊版本的`erase`
- `forward_list`不支持`pop_back`
- `vector`和`string`不支持`pop_front`
- 删除位置之后的跌迭代器会失效

### 特殊的forwad_list操作

- 链表在删除元素时需要修改前置节点的内容，双向链表会前驱的指针，但是单向链表没有保存，因此需要增加获取前置节点的方法。
- `forward_list`定义了`before_begin`，即首前（off-the-begining）迭代器，允许我们再在首元素之前添加或删除元素。

| 操作                        | 解释                                                         |
| --------------------------- | ------------------------------------------------------------ |
| `lst.before_begin()`        | 返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。 |
| `lst.cbefore_begin()`       | 同上，但是返回的是常量迭代器。                               |
| `lst.insert_after(p, t)`    | 在迭代器`p`之后插入元素。`t`是一个对象                       |
| `lst.insert_after(p, n, t)` | 在迭代器`p`之后插入元素。`t`是一个对象，`n`是数量。若`n`是0则函数行为未定义 |
| `lst.insert_after(p, b, e)` | 在迭代器`p`之后插入元素。由迭代器`b`和`e`指定范围。          |
| `lst.insert_after(p, il)`   | 在迭代器`p`之后插入元素。由`il`指定初始化列表。              |
| `emplace_after(p, args)`    | 使用`args`在`p`之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若`p`为尾后迭代器，则函数行为未定义。 |
| `lst.erase_after(p)`        | 删除`p`指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若`p`指向`lst`的尾元素或者是一个尾后迭代器，则函数行为未定义。 |
| `lst.erase_after(b, e)`     | 类似上面，删除对象换成从`b`到`e`指定的范围。                 |

### 改变容器大小

| 操作             | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
| `c.resize(n)`    | 调整`c`的大小为`n`个元素，若`n<c.size()`，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化 |
| `c.resize(n, t)` | 调整`c`的大小为`n`个元素，任何新添加的元素都初始化为值`t`    |

### 获取迭代器

| 操作                     | 解释                                        |
| ------------------------ | ------------------------------------------- |
| `c.begin()`, `c.end()`   | 返回指向`c`的首元素和尾元素之后位置的迭代器 |
| `c.cbegin()`, `c.cend()` | 返回`const_iterator`                        |

- 以`c`开头的版本是C++11新标准引入的
- 当不需要写访问时，应该使用`cbegin`和`cend`。

### 反向容器的额外成员

| 操作                       | 解释                                        |
| -------------------------- | ------------------------------------------- |
| `reverse_iterator`         | 按逆序寻址元素的迭代器                      |
| `const_reverse_iterator`   | 不能修改元素的逆序迭代器                    |
| `c.rbegin()`, `c.rend()`   | 返回指向`c`的尾元素和首元素之前位置的迭代器 |
| `c.crbegin()`, `c.crend()` | 返回`const_reverse_iterator`                |

- 不支持`forward_list`

### 迭代器

- 迭代器范围：`begin`到`end`，即第一个元素到最后一个元素的后面一个位置。
- 左闭合区间：`[begin, end)`
- 左闭合范围蕴含的编程设定：
  - 如果`begin`和`end`相等，则范围为空。
  - 如果二者不等，则范围至少包含一个元素，且`begin`指向该范围中的第一个元素。
  - 可以对`begin`递增若干次，使得`begin == end`。

### 容器操作可能使迭代器失效

- 在向容器添加元素后：
  - 如果容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器、指针、引用都会失效。
  - 对于`deque`，插入到除首尾位置之外的任何位置都会导致指向容器的迭代器、指针、引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的引用和指针不会失效。
  - 对于`list`和`forward_list`，指向容器的迭代器、指针和引用依然有效。
- 在从一个容器中删除元素后：
  - 对于`list`和`forward_list`，指向容器其他位置的迭代器、引用和指针仍然有效。
  - 对于`deque`，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、指针、引用都会失效；如果是删除`deque`的尾元素，则尾后迭代器会失效，但其他不受影响；如果删除的是`deque`的头元素，这些也不会受影响。
  - 对于`vector`和`string`，指向被删元素之前的迭代器、引用、指针仍然有效。
  - 注意：当我们删除元素时，尾后迭代器总是会失效。
  - 注意：使用失效的迭代器、指针、引用是严重的运行时错误！
  - 建议：将要求迭代器必须保持有效的程序片段最小化。
  - 建议：不要保存`end`返回的迭代器。

### 容器内元素的类型约束

- 元素类型必须支持赋值运算；
- 元素类型的对象必须可以复制。
- 除了输入输出标准库类型外，其他所有标准库类型都是有效的容器元素类型。

## vector对象是如何增长的

`vector`和`string`在内存中是连续保存的，如果原先分配的内存位置已经使用完，则需要重新分配新空间，将已有元素从就位置移动到新空间中，然后添加新元素。

### 管理容量的成员函数

| 操作                | 解释                                          |
| ------------------- | --------------------------------------------- |
| `c.shrink_to_fit()` | 将`capacity()`减少到和`size()`相同大小        |
| `c.capacity()`      | 不重新分配内存空间的话，`c`可以保存多少个元素 |
| `c.reverse(n)`      | 分配至少能容纳`n`个元素的内存空间             |

- `shrink_to_fit`只适用于`vector`、`string`和`deque`
- `capacity`和`reverse`只适用于`vector`和`string`。

## 额外的string操作

### 构造string的其他方法

| 操作                       | 解释                                                         |
| -------------------------- | ------------------------------------------------------------ |
| `string s(cp, n)`          | `s`是`cp`指向的数组中前`n`个字符的拷贝，此数组               |
| `string s(s2, pos2)`       | `s`是`string s2`从下标`pos2`开始的字符的拷贝。若`pos2 > s2.size()`，则构造函数的行为未定义。 |
| `string s(s2, pos2, len2)` | `s`是`string s2`从下标`pos2`开始的`len2`个字符的拷贝。       |

- `n`,`len2`,`pos2`都是无符号值。

### substr操作

| 操作               | 解释                                                         |
| ------------------ | ------------------------------------------------------------ |
| `s.substr(pos, n)` | 返回一个`string`，包含`s`中从`pos`开始的`n`个字符的拷贝。`pos`的默认值是0，`n`的默认值是`s.size() - pos`，即拷贝从`pos`开始的所有字符。 |

### 改变string的其他方法

| 操作                     | 解释                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `s.insert(pos, args)`    | 在`pos`之前插入`args`指定的字符。`pos`可以使是下标或者迭代器。接受下标的版本返回指向`s`的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。 |
| `s.erase(pos, len)`      | 删除从`pos`开始的`len`个字符，如果`len`被省略，则删除后面所有字符，返回指向`s`的引用。 |
| `s.assign(args)`         | 将`s`中的字符替换成`args`指定的字符。返回一个指向`s`的引用。 |
| `s.append(args)`         | 将`args`指定的字符追加到`s`，返回一个指向`s`的引用。         |
| `s.replace(range, args)` | 删除`s`中范围`range`中的字符，替换成`args`指定的字符。返回一个指向`s`的引用。 |

### string搜索操作

- `string`类提供了6个不同的搜索函数，每个函数都有4个重载版本。
- 每个搜索操作都返回一个`string::size_type`值，表示匹配发生位置的下标。如果搜索失败则返回一个名为`string::npos`的`static`成员（类型是`string::size_type`，初始化值是-1，也就是`string`最大的可能大小）。

| 搜索操作                    | 解释                                              |
| --------------------------- | ------------------------------------------------- |
| `s.find(args)`              | 查找`s`中`args`第一次出现的位置                   |
| `s.rfind(args)`             | 查找`s`中`args`最后一次出现的位置                 |
| `s.find_first_of(args)`     | 在`s`中查找`args`中任何一个字符第一次出现的位置   |
| `s.find_last_of(args)`      | 在`s`中查找`args`中任何一个字符最后一次出现的位置 |
| `s.find_first_not_of(args)` | 在`s`中查找第一个不在`args`中的字符               |
| `s.find_first_not_of(args)` | 在`s`中查找最后一个不在`args`中的字符             |

args必须是一下的形式之一：

| `args`形式   | 解释                                                         |
| ------------ | ------------------------------------------------------------ |
| `c, pos`     | 从`s`中位置`pos`开始查找字符`c`。`pos`默认是0                |
| `s2, pos`    | 从`s`中位置`pos`开始查找字符串`s`。`pos`默认是0              |
| `cp, pos`    | 从`s`中位置`pos`开始查找指针`cp`指向的以空字符结尾的C风格字符串。`pos`默认是0 |
| `cp, pos, n` | 从`s`中位置`pos`开始查找指针`cp`指向的前`n`个字符。`pos`和`n`无默认值。 |

### s.compare的几种参数形式

逻辑类似于C标准库的`strcmp`函数，根据`s`是等于、大于还是小于参数指定的字符串，`s.compare`返回0、正数或负数。

| 参数形式                 | 解释                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `s2`                     | 比较`s`和`s2`                                                |
| `pos1, n1, s2`           | 比较`s`从`pos1`开始的`n1`个字符和`s2`                        |
| `pos1, n1, s2, pos2, n2` | 比较`s`从`pos1`开始的`n1`个字符和`s2`                        |
| `cp`                     | 比较`s`和`cp`指向的以空字符结尾的字符数组                    |
| `pos1, n1, cp`           | 比较`s`从`pos1`开始的`n1`个字符和`cp`指向的以空字符结尾的字符数组 |
| `pos1, n1, cp, n2`       | 比较`s`从`pos1`开始的`n1`个字符和`cp`指向的地址开始`n2`个字符 |

### string和数值转换

| 转换              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| `to_string(val)`  | 一组重载函数，返回数值`val`的`string`表示。`val`可以使任何算术类型。对每个浮点类型和`int`或更大的整型，都有相应版本的`to_string()`。和往常一样，小整型会被提升。 |
| `stoi(s, p, b)`   | 返回`s`起始子串（表示整数内容）的数值，`p`是`s`中第一个非数值字符的下标，默认是0，`b`是转换所用的基数。返回`int` |
| `stol(s, p, b)`   | 返回`long`                                                   |
| `stoul(s, p, b)`  | 返回`unsigned long`                                          |
| `stoll(s, p, b)`  | 返回`long long`                                              |
| `stoull(s, p, b)` | 返回`unsigned long long`                                     |
| `stof(s, p)`      | 返回`s`起始子串（表示浮点数内容）的数值，`p`是`s`中第一个非数值字符的下标，默认是0。返回`float` |
| `stod(s, p)`      | 返回`double`                                                 |
| `stold(s, p)`     | 返回`long double`                                            |

## 容器适配器（adapter）

- 适配器是使一事物的行为类似于另一事物的行为的一种机制，例如`stack`可以使任何一种顺序容器以栈的方式工作。
- 初始化 `deque<int> deq; stack<int> stk(deq);` 从`deq`拷贝元素到`stk`。
- 创建适配器时，指定一个顺序容器，可以覆盖默认的基础容器： `stack<string, vector<string> > str_stk;`。

### 适配器的通用操作和类型

| 操作             | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
| `size_type`      | 一种类型，须以保存当前类型的最大对象的大小                   |
| `value_type`     | 元素类型                                                     |
| `container_type` | 实现适配器的底层容器类型                                     |
| `A a;`           | 创建一个名为`a`的空适配器                                    |
| `A a(c)`         | 创建一个名为`a`的适配器，带有容器`c`的一个拷贝               |
| 关系运算符       | 每个适配器都支持所有关系运算符：`==`、`!=`、`<`、 `<=`、`>`、`>=`这些运算符返回底层容器的比较结果 |
| `a.empty()`      | 若`a`包含任何元素，返回`false`;否则返回`true`                |
| `a.size()`       | 返回`a`中的元素数目                                          |
| `swap(a, b)`     | 交换`a`和`b`的内容，`a`和`b`必须有相同类型，包括底层容器类型也必须相同 |
| `a.swap(b)`      | 同上                                                         |

### stack

| 操作              | 解释                                                     |
| ----------------- | -------------------------------------------------------- |
| `s.pop()`         | 删除栈顶元素，不返回。                                   |
| `s.push(item)`    | 创建一个新元素，压入栈顶，该元素通过拷贝或移动`item`而来 |
| `s.emplace(args)` | 同上，但元素由`args`来构造。                             |
| `s.top()`         | 返回栈顶元素，不删除。                                   |

- 定义在`stack`头文件中。
- `stack`默认基于`deque`实现，也可以在`list`或`vector`之上实现。

### queue和priority_queue

| 操作              | 解释                                      |
| ----------------- | ----------------------------------------- |
| `q.pop()`         | 删除队首元素，但不返回。                  |
| `q.front()`       | 返回队首元素的值，不删除。                |
| `q.back()`        | 返回队尾元素的值，不删除。只适用于`queue` |
| `q.top()`         | 返回具有最高优先级的元素值，不删除。      |
| `q.push(item)`    | 在队尾压入一个新元素。                    |
| `q.emplace(args)` |                                           |

- 定义在`queue`头文件中。
- `queue`默认基于`deque`实现，`priority_queue`默认基于`vector`实现。
- `queue`可以在`list`或`vector`之上实现，`priority_queue`也可以用`deque`实现。

# 第十章 泛型算法

## 泛型算法

因为它们实现共同的操作，所以称之为“**算法**”；而“**泛型**”、指的是它们可以操作在多种容器类型上。泛型算法不会直接调用容器的操作，而是通过迭代器来访问、修改、移动元素。

泛型算法本身不执行容器操作，只是单独依赖迭代器和迭代器操作实现。

- 头文件： `#include <algorithm>`或者 `#include <numeric>`(算数相关)
- 大多数算法是通过遍历两个迭代器标记的一段元素来实现其功能。
- 必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但不能直接添加或者删除元素。

### find

- `vector<int>::const_iterator result = find(vec.begin(), vec.end(), search_value);`
- 输入：两个标记范围的迭代器和目标查找值。返回：如果找到，返回对应的迭代器，否则返回第二个参数，即标记结尾的迭代器。

## 初识泛型算法

- 标准库提供了超过100个算法，但这些算法有一致的结构。
- 理解算法的最基本的方法是了解它们是否读取元素、改变元素、重排元素顺序。

### 只读算法

- 只读取范围中的元素，不改变元素。
- 如 `find`和 `accumulate`（在`numeric`中定义，求和）。
- `find_first_of`，输入：两对迭代器标记两段范围，在第一段中找第二段中任意元素，返回第一个匹配的元素，找不到返回第一段的`end`迭代器。
- 通常最好使用`cbegin`和`cend`。
- `equal`：确定两个序列是否保存相同的值。

### 写容器元素的算法

- 一些算法将新值赋予序列中的元素。
- 算法不检查写操作。
- `fill`： `fill(vec.begin(), vec.end(), 0);` 将每个元素重置为0
- `fill_n`： `fill_n(vec.begin(), 10, 0);`
- 插入迭代器`back_inserter`：
  - 用来确保算法有足够的空间存储数据。
  - `#include <iterator>`
  - `back_inserter(vec)`
- 拷贝算法`copy`：
- 输入：前两个参数指定输入范围，第三个指向目标序列。
- `copy (ilst.begin(), ilst.end(), back_inserter(ivec));`
- `copy`时必须保证目标目的序列至少要包含与输入序列一样多的元素。

### 重排容器元素的算法

- 这些算法会重排容器中元素的顺序。
- 排序算法`sort`：
  - 接受两个迭代器，表示要排序的元素范围。
- 消除重复`unique`：
  - 之前要先调用`sort`
  - 返回的迭代器指向最后一个不重复元素之后的位置。
  - 顺序会变，重复的元素被“删除”。
  - 并没有真正删除，真正删除必须使用容器操作。

## 定制操作

### 向算法传递函数：

- 谓词（`predicate`）：
  - 是一个**可调用的表达式**，返回结果是一个能用作条件的值
  - 一元谓词：接受一个参数
  - 二元谓词：接受两个参数

- 例子：
  - `stable_sort`：
    - 保留相等元素的原始相对位置。
    - `stable_sort(words.begin(), words.end(), isShorter);`

### lambda表达式

- 有时可能希望操作可以接受更多的参数。
- `lambda`表达式表示一个可调用的代码单元，可以理解成是一个未命名的内联函数。
- 形式：`[capture list](parameter list) -> return type {function body}`。
  - 其中`capture list`捕获列表是一个`lambda`所在函数定义的局部变量的列表（通常为空）。不可忽略。
  - `return type`是返回类型。可忽略。
  - `parameter`是参数列表。可忽略。
  - `function body`是函数体。不可忽略。
  - `auto f = [] {return 42;}`

- 例子：
  - `find_if`:
    - 接受一对表示范围的迭代器和一个谓词，用来查找第一个满足特定要求的元素。返回第一个使谓词返回非0值的元素。
    - `auto wc = find_if(words.begin(), words.end(), [sz](const string &a){return a.size() >= sz;});`
  - `for_each`：
    - 接受一个可调用对象，并对序列中每个元素调用此对象。
    - `for_each(wc, words.end(), [](const string &s){cout << s << " ";})`

### lambda捕获和返回

- 定义`lambda`时会生成一个新的类类型和该类型的一个对象。
- 默认情况下，从`lambda`生成的类都包含一个对应该`lambda`所捕获的变量的数据成员，在`lambda`对象创建时被初始化。
- **值捕获**：前提是变量可以拷贝，`size_t v1 = 42; auto f = [v1] {return v1;};`。
- **引用捕获**：必须保证在`lambda`执行时，变量是存在的，`auto f2 = [&v1] {return v1;};`
- 尽量减少捕获的数据量，尽可能避免捕获指针或引用。
- **隐式捕获**：让编译器推断捕获列表，在捕获列表中写一个`&`（引用方式）或`=`（值方式）。`auto f3 = [=] {return v1;}`

**lambda捕获列表**：

| 捕获列表               | 解释                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `[]`                   | 空捕获列表。`lambda`不能使用所在函数中的变量。一个`lambda`只有在捕获变量后才能使用它们。 |
| `[names]`              | `names`是一个逗号分隔的名字列表，这些名字都是在`lambda`所在函数的局部变量，捕获列表中的变量都被拷贝，名字前如果使用了`&`，则采用引用捕获方式。 |
| `[&]`                  | 隐式捕获列表，采用引用捕获方式。`lambda`体中所使用的来自所在函数的实体都采用引用方式使用。 |
| `[=]`                  | 隐式捕获列表，采用值捕获方式。                               |
| `[&, identifier_list]` | `identifier_list`是一个逗号分隔的列表，包含0个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。`identifier_list`中的名字前面不能使用`&` |
| `[=, identifier_list]` | `identifier_list`中的变量采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。`identifier_list`中的名字不能包括`this`，且前面必须使用`&` |

### 参数绑定

- `lambda`表达式更适合在一两个地方使用的简单操作。
- 如果是很多地方使用相同的操作，还是需要定义函数。
- 函数如何包装成一元谓词？使用参数绑定。
- 标准库`bind`函数：
  - 定义在头文件`functional`中，可以看做为一个通用的函数适配器。
  - `auto newCallable = bind(callable, arg_list);`
  - 我们再调用`newCallable`的时候，`newCallable`会调用`callable`并传递给它`arg_list`中的参数。
  - `_n`代表第n个位置的参数。定义在`placeholders`的命名空间中。`using std::placeholder::_1;`
  - `auto g = bind(f, a, b, _2, c, _1);`，调用`g(_1, _2)`实际上调用`f(a, b, _2, c, _1)`
  - 非占位符的参数要使用引用传参，必须使用标准库`ref`函数或者`cref`函数。

## 再探迭代器

### 插入迭代器

- 插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，能实现向给定容器添加元素。
- 三种类型：
  - `back_inserter`：创建一个使用`push_back`的迭代器。
  - `front_inserter`创建一个使用`push_front`的迭代器。
  - `inserter`创建一个使用`insert`的迭代器。接受第二个参数，即一个指向给定容器的迭代器，元素会被查到迭代器所指向的元素之前。

**插入迭代器操作**：

| 操作              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| `it=t`            | 在`it`指定的当前位置插入值`t`。假定`c`是`it`绑定的容器，依赖于插入迭代器的不同种类，此赋值会分别调用`c.push_back(t)`、`c.push_front(t)`、`c.insert(t, p)`，其中`p`是传递给`inserter`的迭代器位置 |
| `*it, ++it, it++` | 这些操作虽然存在，但不会对`it`做任何事情，每个操作都返回`it` |

### iostream迭代器

- 迭代器可与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流。
- 通过使用流迭代器，我们可以用泛型算法从流对象中读取数据以及向其写入数据。

**istream_iterator的操作**：

| 操作                          | 解释                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `istream_iterator<T> in(is);` | `in`从输入流`is`读取类型为`T`的值                            |
| `istream_iterator<T> end;`    | 读取类型是`T`的值的`istream_iterator`迭代器，表示尾后位置    |
| `in1 == in2`                  | `in1`和`in2`必须读取相同类型。如果他们都是尾后迭代器，或绑定到相同的输入，则两者相等。 |
| `in1 != in2`                  | 类似上条                                                     |
| `*in`                         | 返回从流中读取的值                                           |
| `in->mem`                     | 与`*(in).mem`含义相同                                        |
| `++in, in++`                  | 使用元素类型所定义的`>>`运算符从流中读取下一个值。前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值。 |

**ostream_iterator的操作**：

| 操作                              | 解释                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| `ostream_iterator<T> out(os);`    | `out`将类型为`T`的值写到输出流`os`中                         |
| `ostream_iterator<T> out(os, d);` | `out`将类型为`T`的值写到输出流`os`中，每个值后面都输出一个`d`。`d`指向一个空字符结尾的字符数组。 |
| `out = val`                       | 用`<<`运算符将`val`写入到`out`所绑定的`ostream`中。`val`的类型必须和`out`可写的类型兼容。 |
| `*out, ++out, out++`              | 这些运算符是存在的，但不对`out`做任何事情。每个运算符都返回`out`。 |

### 反向迭代器

- 反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。
- 对于反向迭代器，递增和递减的操作含义会颠倒。
- 实现向后遍历，配合`rbegin`和`rend`。

## 泛型算法结构

### 5类迭代器

| 迭代器类别     | 解释                                 | 支持的操作                                                   |
| -------------- | ------------------------------------ | ------------------------------------------------------------ |
| 输入迭代器     | 只读，不写；单遍扫描，只能递增       | `==`,`!=`,`++`,`*`,`->`                                      |
| 输出迭代器     | 只写，不读；单遍扫描，只能递增       | `++`,`*`                                                     |
| 前向迭代器     | 可读写；多遍扫描，只能递增           | `==`,`!=`,`++`,`*`,`->`                                      |
| 双向迭代器     | 可读写；多遍扫描，可递增递减         | `==`,`!=`,`++`,`--`,`*`,`->`                                 |
| 随机访问迭代器 | 可读写，多遍扫描，支持全部迭代器运算 | `==`,`!=`,`<`,`<=`,`>`,`>=`,`++`,`--`,`+`,`+=`,`-`,`-=`,`*`,`->`,`iter[n]`==`*(iter[n])` |

### 算法的形参模式

- `alg(beg, end, other args);`
- `alg(beg, end, dest, other args);`
- `alg(beg, end, beg2, other args);`
- `alg(beg, end, beg2, end2, other args);`

其中，`alg`是算法名称，`beg`和`end`表示算法所操作的输入范围。`dest`、`beg2`、`end2`都是迭代器参数，是否使用要依赖于执行的操作。

### 算法命名规范

- 一些算法使用重载形式传递一个谓词。
- 接受一个元素值的算法通常有一个**不同名**的版本：加`_if`，接受一个谓词代替元素值。
- 区分拷贝元素的版本和不拷贝的版本：拷贝版本通常加`_copy`。

## 特定容器算法

- 对于`list`和`forward_list`，优先使用成员函数版本的算法而不是通用算法。

**list和forward_list成员函数版本的算法**：

| 操作                    | 解释                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `lst.merge(lst2)`       | 将来自`lst2`的元素合并入`lst`，二者都必须是有序的，元素将从`lst2`中删除。 |
| `lst.merge(lst2, comp)` | 同上，给定比较操作。                                         |
| `lst.remove(val)`       | 调用`erase`删除掉与给定值相等(==)的每个元素                  |
| `lst.remove_if(pred)`   | 调用`erase`删除掉令一元谓词为真的每个元素                    |
| `lst.reverse()`         | 反转`lst`中元素的顺序                                        |
| `lst.sort()`            | 使用`<`排序元素                                              |
| `lst.sort(comp)`        | 使用给定比较操作排序元素                                     |
| `lst.unique()`          | 调用`erase`删除同一个值的连续拷贝。使用`==`。                |
| `lst.unique(pred)`      | 调用`erase`删除同一个值的连续拷贝。使用给定的二元谓词。      |

- 上面的操作都返回`void`

**list和forward_list的splice成员函数版本的参数**：

| 参数              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| `(p, lst2)`       | `p`是一个指向`lst`中元素的迭代器，或者一个指向`flst`首前位置的迭代器。函数将`lst2`中的所有元素移动到`lst`中`p`之前的位置或是`flst`中`p`之后的位置。将元素从`lst2`中删除。`lst2`的类型必须和`lst`相同，而且不能是同一个链表。 |
| `(p, lst2, p2)`   | 同上，`p2`是一个指向`lst2`中位置的有效的迭代器，将`p2`指向的元素移动到`lst`中，或将`p2`之后的元素移动到`flst`中。`lst2`可以是于`lst`或`flst`相同的链表。 |
| `(p, lst2, b, e)` | `b`和`e`表示`lst2`中的合法范围。将给定范围中的元素从`lst2`移动到`lst`或`first`中。`lst2`与`lst`可以使相同的链表，但`p`不能指向给定范围中的元素。 |

- 使用`lst.splice(args)`或`flst.splice_after(args)`

# 第十一章 关联容器

- 关联容器和顺序容器的不同：关联容器中的元素时按照**关键字**来保存和访问的。
- 关联容器支持通过关键字来高效地查找和读取元素，基本的关联容器类型是 `map`和 `set`。

**与顺序容器的区别：**

**顺序容器**中每一个元素都有唯一的对应的位置编号，底层数据结构是数组、链表，对于获取元素、遍历元素是十分高效的，但对于搜索元素却效率不佳。

**关联容器**为了高效实现按值访问元素这类操作而设计。容器中关键字与元素建立对应的关系，这就是“关联”的含义，底层数据结构是红黑树、哈希表等。

**关联容器类型**：

| 容器类型             | 解释                                |
| -------------------- | ----------------------------------- |
| 按顺序存储           |                                     |
| `map`                | 关键数组：保存`关键字-值`对         |
| `set`                | 关键字即值，即只保存关键字的容器    |
| `multimap`           | 支持同一个键多次出现的`map`         |
| `multiset`           | 支持同一个键多次出现的`set`         |
| 无序集合             |                                     |
| `unordered_map`      | 用哈希函数组织的`map`               |
| `unordered_set`      | 用哈希函数组织的`set`               |
| `unordered_multimap` | 哈希组织的`map`，关键字可以重复出现 |
| `unordered_multiset` | 哈希组织的`set`，关键字可以重复出现 |

## 关联容器概述

### 定义关联容器

- 需要指定元素类型。
- 列表初始化：
  - `map`：`map<string, int> word_count = {{"a", 1}, {"b", 2}};`
  - `set`：`set<string> exclude = {"the", "a"};`

### 关键字类型的要求

- 对于有序容器，关键字类型必须定义元素比较的方法。默认是`<`。
- 如果想传递一个比较的函数，可以这样定义：`multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);`

### pair

- 在`utility`头文件中定义。
- 一个`pair`保存两个数据成员，两个类型不要求一样。

**pair的操作**：

| 操作                        | 解释                                                         |
| --------------------------- | ------------------------------------------------------------ |
| `pair<T1, T2> p;`           | `p`是一个`pair`，两个类型分别是`T1`和`T2`的成员都进行了值初始化。 |
| `pair<T1, T2> p(v1, v2);`   | `first`和`second`分别用`v1`和`v2`进行初始化。                |
| `pair<T1, T2>p = {v1, v2};` | 等价于`p(v1, v2)                                             |
| `make_pair(v1, v2);`        | `pair`的类型从`v1`和`v2`的类型推断出来。                     |
| `p.first`                   | 返回`p`的名为`first`的数据成员。                             |
| `p.second`                  | 返回`p`的名为`second`的数据成员。                            |
| `p1 relop p2`               | 运算关系符按字典序定义。                                     |
| `p1 == p2`                  | 必须两对元素两两相等                                         |
| `p1 != p2`                  | 同上                                                         |

## 关联容器操作

**关联容器额外的类型别名**：

| 类型别名      | 解释                                                         |
| ------------- | ------------------------------------------------------------ |
| `key_type`    | 此容器类型的关键字类型                                       |
| `mapped_type` | 每个关键字关联的类型，只适用于`map`                          |
| `value_type`  | 对于`map`，是`pair<const key_type, mapped_type>`; 对于`set`，和`key_type`相同。 |

### 关联容器迭代器

- 解引用一个关联容器迭代器时，会得到一个类型为容器的`value_type`的值的引用。
- `set`的迭代器是`const`的。
- 遍历关联容器：使用`begin`和`end`，遍历`map`、`multimap`、`set`、`multiset`时，迭代器按**关键字升序**遍历元素。

### 添加元素

**关联容器`insert`操作**：

| `insert`操作                           | 关联容器                                                     |
| -------------------------------------- | ------------------------------------------------------------ |
| `c.insert(v)`  `c.emplace(args)`       | `v`是`value_type`类型的对象；`args`用来构造一个元素。 对于`map`和`set`，只有元素的关键字不存在`c`中才插入或构造元素。函数返回一个`pair`，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的`bool`值。对于`multimap`和`multiset`则会插入范围中的每个元素。 |
| `c.insert(b, e)` `c.insert(il)`        | `b`和`e`是迭代器，表示一个`c::value_type`类型值的范围；`il`是这种值的花括号列表。函数返回`void`。对于 `map`和`set`，只插入关键字不在`c`中的元素。 |
| `c.insert(p, v)`  `c.emplace(p, args)` | 类似`insert(v)`，但将迭代器`p`作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素。 |

向`map`添加元素：
- `word_count.insert({word, 1});`
- `word_count.insert(make_pair(word, 1));`
- `word_count.insert(pair<string, size_t>(word, 1));`
- `word_count.insert(map<string, size_t>::value_type (word, 1));`

### 删除元素

**从关联容器中删除元素**：

| 操作            | 解释                                                         |
| --------------- | ------------------------------------------------------------ |
| `c.erase(k)`    | 从`c`中删除每个关键字为`k`的元素。返回一个`size_type`值，指出删除的元素的数量。 |
| `c.erase(p)`    | 从`c`中删除迭代器`p`指定的元素。`p`必须指向`c`中一个真实元素，不能等于`c.end()`。返回一个指向`p`之后元素的迭代器，若`p`指向`c`中的尾元素，则返回`c.end()` |
| `c.erase(b, e)` | 删除迭代器对`b`和`e`所表示范围中的元素。返回`e`。            |

### 下标操作

**`map`和`unordered_map`的下标操作**：

| 操作      | 解释                                                         |
| --------- | ------------------------------------------------------------ |
| `c[k]`    | 返回关键字为`k`的元素；如果`k`不在`c`中，添加一个关键字为`k`的元素，对其值初始化。 |
| `c.at(k)` | 访问关键字为`k`的元素，带参数检查；若`k`不存在在`c`中，抛出一个`out_of_range`异常。 |

### 查找元素

**在一个关联容器中查找元素**:

| 操作               | 解释                                                         |
| ------------------ | ------------------------------------------------------------ |
| `c.find(k)`        | 返回一个迭代器，指向第一个关键字为`k`的元素，若`k`不在容器中，则返回尾后迭代器 |
| `c.count(k)`       | 返回关键字等于`k`的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1。 |
| `c.lower_bound(k)` | 返回一个迭代器，指向第一个关键字**不小于**`k`的元素。        |
| `c.upper_bound(k)` | 返回一个迭代器，指向第一个关键字**大于**`k`的元素。          |
| `c.equal_range(k)` | 返回一个迭代器`pair`，表示关键字等于`k`的元素的范围。若`k`不存在，`pair`的两个成员均等于`c.end()`。 |

- `lower_bound`和`upper_bound`不适用于无序容器。
- 下标和`at`操作只适用于非`const`的`map`和`unordered_map`。
- 具有相同关键字的元素在容器中会相邻存储。

## 无序容器

- 有序容器使用比较运算符来组织元素；无序容器使用哈希函数和关键字类型的`==`运算符。
- 理论上哈希技术可以获得更好的性能。无序容器的性能依赖于哈希函数的质量和桶的数量大小。
- 无序容器在存储上组织为一组桶(bucket)，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。

**无序容器管理操作**：

| 操作                       | 解释                                                         |
| -------------------------- | ------------------------------------------------------------ |
| **桶接口**                 |                                                              |
| `c.bucket_count()`         | 正在使用的桶的数目                                           |
| `c.max_bucket_count()`     | 容器能容纳的最多的桶的数目                                   |
| `c.bucket_size(n)`         | 第`n`个桶中有多少个元素                                      |
| `c.bucket(k)`              | 关键字为`k`的元素在哪个桶中                                  |
| **桶迭代**                 |                                                              |
| `local_iterator`           | 可以用来访问桶中元素的迭代器类型                             |
| `const_local_iterator`     | 桶迭代器的`const`版本                                        |
| `c.begin(n)`，`c.end(n)`   | 桶`n`的首元素迭代器                                          |
| `c.cbegin(n)`，`c.cend(n)` | 与前两个函数类似，但返回`const_local_iterator`。             |
| **哈希策略**               |                                                              |
| `c.load_factor()`          | 每个桶的平均元素数量，返回`float`值。                        |
| `c.max_load_factor()`      | `c`试图维护的平均比桶大小，返回`float`值。`c`会在需要时添加新的桶，以使得`load_factor<=max_load_factor` |
| `c.rehash(n)`              | 重组存储，使得`bucket_count>=n`，且`bucket_count>size/max_load_factor` |
| `c.reverse(n)`             | 重组存储，使得`c`可以保存`n`个元素且不必`rehash`。           |

# 第十二章 动态内存

- 对象的生命周期：
  - 全局对象在程序启动时分配，结束时销毁。
  - 局部对象在进入程序块时创建，离开块时销毁。
  - 局部`static`对象在第一次使用前分配，在程序结束时销毁。
  - 动态分配对象：只能显式地被释放。

- 对象的内存位置：
  - **静态内存**用来保存局部`static`对象、类`static`对象、定义在任何函数之外的变量。
  - **栈内存**用来保存定义在函数内的非`static`对象。
  - **堆内存**，又称自由空间，用来存储**动态分配**的对象。

## 动态内存与智能指针

- 动态内存管理：
  - `new`：在动态内存中为对象分配空间并返回一个指向该对象的指针。
  - `delete`：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。
- 智能指针：
  - 管理动态对象。
  - 行为类似常规指针。
  - 负责自动释放所指向的对象。
  - 智能指针也是模板。

### shared_ptr类

**shared_ptr和unique_ptr都支持的操作**：

| 操作                                   | 解释                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| `shared_ptr<T> sp`  `unique_ptr<T> up` | 空智能指针，可以指向类型是`T`的对象                          |
| `p`                                    | 将`p`用作一个条件判断，若`p`指向一个对象，则为`true`         |
| `*p`                                   | 解引用`p`，获得它指向的对象。                                |
| `p->mem`                               | 等价于`(*p).mem`                                             |
| `p.get()`                              | 返回`p`中保存的指针，要小心使用，若智能指针释放了对象，返回的指针所指向的对象也就消失了。 |
| `swap(p, q)` `p.swap(q)`               | 交换`p`和`q`中的指针                                         |

**shared_ptr独有的操作**：

| 操作                   | 解释                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `make_shared<T>(args)` | 返回一个`shared_ptr`，指向一个动态分配的类型为`T`的对象。使用`args`初始化此对象。 |
| `shared_ptr<T>p(q)`    | `p`是`shared_ptr q`的拷贝；此操作会**递增**`q`中的计数器。`q`中的指针必须能转换为`T*` |
| `p = q`                | `p`和`q`都是`shared_ptr`，所保存的指针必须能互相转换。此操作会**递减**`p`的引用计数，**递增**`q`的引用计数；若`p`的引用计数变为0，则将其管理的原内存释放。 |
| `p.unique()`           | 若`p.use_count()`是1，返回`true`；否则返回`false`            |
| `p.use_count()`        | 返回与`p`共享对象的智能指针数量；可能很慢，主要用于调试。    |

- **使用动态内存的三种原因**：
  - 程序不知道自己需要使用多少对象（比如容器类）。
  - 程序不知道所需要对象的准确类型。
  - 程序需要在多个对象间共享数据。

### 直接管理内存

- 用`new`动态分配和初始化对象。
  - `new`无法为分配的对象命名（因为自由空间分配的内存是无名的），因此是返回一个指向该对象的指针。
  - `int *pi = new int(123);`
  - 一旦内存耗尽，会抛出类型是`bad_alloc`的异常。
- 用`delete`将动态内存归还给系统。
  - 接受一个指针，指向要释放的对象。
  - `delete`后的指针称为空悬指针（dangling pointer）。
- 使用`new`和`delete`管理动态内存存在三个常见问题：
  - 1.忘记`delete`内存。
  - 2.使用已经释放掉的对象。
  - 3.同一块内存释放两次。
- 坚持只使用智能指针可以避免上述所有问题。

### shared_ptr和new结合使用

**定义和改变shared_ptr的其他方法**：

| 操作                     | 解释                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `shared_ptr<T> p(q)`     | `p`管理内置指针`q`所指向的对象；`q`必须指向`new`分配的内存，且能够转换为`T*`类型 |
| `shared_ptr<T> p(u)`     | `p`从`unique_ptr u`那里接管了对象的所有权；将`u`置为空       |
| `shared_ptr<T> p(q, d)`  | `p`接管了内置指针`q`所指向的对象的所有权。`q`必须能转换为`T*`类型。`p`将使用可调用对象`d`来代替`delete`。 |
| `shared_ptr<T> p(p2, d)` | `p`是`shared_ptr p2`的拷贝，唯一的区别是`p`将可调用对象`d`来代替`delete`。 |
| `p.reset()`              | 若`p`是唯一指向其对象的`shared_ptr`，`reset`会释放此对象。若传递了可选的参数内置指针`q`，会令`p`指向`q`，否则会将`p`置空。若还传递了参数`d`，则会调用`d`而不是`delete`来释放`q`。 |
| `p.reset(q)`             | 同上                                                         |
| `p.reset(q, d)`          | 同上                                                         |

### 智能指针和异常

- 如果使用智能指针，即使程序块由于异常过早结束，智能指针类也能确保在内存不需要的时候将其释放。
- **智能指针陷阱**：
  - 不用相同的内置指针初始化（或`reset`）多个智能指针
  - 不`delete get()`返回的指针。
  - 如果你使用`get()`返回的指针，记得当最后一个对应的智能指针销毁后，你的指针就无效了。
  - 如果你使用智能指针管理的资源不是`new`分配的内存，记住传递给它一个删除器。

### unique_ptr

- 某一个时刻只能有一个`unique_ptr`指向一个给定的对象。
- 不支持拷贝或者赋值操作。
- 向后兼容：`auto_ptr`：老版本，具有`unique_ptr`的部分特性。特别是，不能在容器中保存`auto_ptr`，也不能从函数返回`auto_ptr`。

**unique_ptr操作**:

| 操作                    | 解释                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `unique_ptr<T> u1`      | 空`unique_ptr`，可以指向类型是`T`的对象。`u1`会使用`delete`来是释放它的指针。 |
| `unique_ptr<T, D> u2`   | `u2`会使用一个类型为`D`的可调用对象来释放它的指针。          |
| `unique_ptr<T, D> u(d)` | 空`unique_ptr`，指向类型为`T`的对象，用类型为`D`的对象`d`代替`delete` |
| `u = nullptr`           | 释放`u`指向的对象，将`u`置为空。                             |
| `u.release()`           | `u`放弃对指针的控制权，返回指针，并将`u`置空。               |
| `u.reset()`             | 释放`u`指向的对象                                            |
| `u.reset(q)`            | 令`u`指向`q`指向的对象                                       |
| `u.reset(nullptr)`      | 将`u`置空                                                    |

### weak_ptr

- `weak_ptr`是一种不控制所指向对象生存期的智能指针。
- 指向一个由`shared_ptr`管理的对象，不改变`shared_ptr`的引用计数。
- 一旦最后一个指向对象的`shared_ptr`被销毁，对象就会被释放，不管有没有`weak_ptr`指向该对象。

**weak_ptr操作**:

| 操作                | 解释                                                         |
| ------------------- | ------------------------------------------------------------ |
| `weak_ptr<T> w`     | 空`weak_ptr`可以指向类型为`T`的对象                          |
| `weak_ptr<T> w(sp)` | 与`shared_ptr`指向相同对象的`weak_ptr`。`T`必须能转换为`sp`指向的类型。 |
| `w = p`             | `p`可以是`shared_ptr`或一个`weak_ptr`。赋值后`w`和`p`共享对象。 |
| `w.reset()`         | 将`w`置为空。                                                |
| `w.use_count()`     | 与`w`共享对象的`shared_ptr`的数量。                          |
| `w.expired()`       | 若`w.use_count()`为0，返回`true`，否则返回`false`            |
| `w.lock()`          | 如果`expired`为`true`，则返回一个空`shared_ptr`；否则返回一个指向`w`的对象的`shared_ptr`。 |

## 动态数组

### new和数组

- `new`一个动态数组：
  - 类型名之后加一对方括号，指明分配的对象数目（必须是整型，不必是常量）。
  - 返回**指向第一个对象的指针**。
  - `int *p = new int[size];`

- `delete`一个动态数组：
  - `delete [] p;`

- `unique_ptr`和数组：
  - 指向数组的`unique_ptr`不支持成员访问运算符（点和箭头）。

| 操作                   | 解释                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `unique_ptr<T[]> u`    | `u`可以指向一个动态分配的数组，整数元素类型为`T`             |
| `unique_ptr<T[]> u(p)` | `u`指向内置指针`p`所指向的动态分配的数组。`p`必须能转换为类型`T*`。 |
| `u[i]`                 | 返回`u`拥有的数组中位置`i`处的对象。`u`必须指向一个数组。    |

### allocator类

- 标准库`allocator`类定义在头文件`memory`中，帮助我们将内存分配和对象构造分离开。
- 分配的是原始的、未构造的内存。
- `allocator`是一个模板。
- `allocator<string> alloc;`

**标准库allocator类及其算法**：

| 操作                   | 解释                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `allocator<T> a`       | 定义了一个名为`a`的`allocator`对象，它可以为类型为`T`的对象分配内存 |
| `a.allocate(n)`        | 分配一段原始的、未构造的内存，保存`n`个类型为`T`的对象。     |
| `a.deallocate(p, n)`   | 释放从`T*`指针`p`中地址开始的内存，这块内存保存了`n`个类型为`T`的对象；`p`必须是一个先前由`allocate`返回的指针。且`n`必须是`p`创建时所要求的大小。在调用`deallocate`之前，用户必须对每个在这块内存中创建的对象调用`destroy`。 |
| `a.construct(p, args)` | `p`必须是一个类型是`T*`的指针，指向一块原始内存；`args`被传递给类型为`T`的构造函数，用来在`p`指向的内存中构造一个对象。 |
| `a.destroy(p)`         | `p`为`T*`类型的指针，此算法对`p`指向的对象执行析构函数。     |

**allocator伴随算法**：

| 操作                             | 解释                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `uninitialized_copy(b, e, b2)`   | 从迭代器`b`和`e`给定的输入范围中拷贝元素到迭代器`b2`指定的未构造的原始内存中。`b2`指向的内存必须足够大，能够容纳输入序列中元素的拷贝。 |
| `uninitialized_copy_n(b, n, b2)` | 从迭代器`b`指向的元素开始，拷贝`n`个元素到`b2`开始的内存中。 |
| `uninitialized_fill(b, e, t)`    | 在迭代器`b`和`e`执行的原始内存范围中创建对象，对象的值均为`t`的拷贝。 |
| `uninitialized_fill_n(b, n, t)`  | 从迭代器`b`指向的内存地址开始创建`n`个对象。`b`必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。 |

- 定义在头文件`memory`中。
- 在给定目的位置创建元素，而不是由系统分配内存给他们。

# 参考

**C++**

代码仓库与笔记

[GitHub-CPP_Primer_Practice](https://github.com/applenob/Cpp_Primer_Practice)

视频

[B站-阿西拜-C++ Primer 第五版](https://www.bilibili.com/video/BV1z64y1U7hs/?p=11&spm_id_from=pageDriver&vd_source=9fd24d506f93429d3b579d92063785a2)

侯捷C++



